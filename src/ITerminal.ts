import {Optional} from "./Optional";
import IPipeline from "./IPipline";
import {TsStream} from "./TsStream";
import {Pipeline} from "./Pipeline";

export default interface ITerminal<T> {
    groupBy(path: string|TsStream.Function<T, string>): TsStream.GroupingResult<T>;
    groupingBy(mapper: TsStream.Function<T, string>): TsStream.GroupingResult<T>;
    groupingBy(path: string): TsStream.GroupingResult<T>;
    indexBy(keyMapper: TsStream.Function<T, string>, mergeFunction?: TsStream.Accumulator<T>): TsStream.Map<T>;
    map <U> (mapper: TsStream.Function<T, U>): IPipeline<U>;
    max(arg?:TsStream.Comparator<T>|string): Optional<T>;
    min(arg?:TsStream.Comparator<T>|string): Optional<T>;
    noneMatch(predicate: (elem: T) => boolean): boolean;
    noneMatch(regexp: RegExp): boolean;
    flatMap <U> (mapper: TsStream.Function<T, U[]>): IPipeline<U>;
    iterator(): TsStream.Iterator<T>;
    joining(): string;
    joining(delimiter: string): string;
    joining(options: TsStream.JoinOptions): string;
    join(): string;
    join(delimiter: string): string;
    join(options: TsStream.JoinOptions): string;
    limit(limit: number): IPipeline<T>;
    partitioningBy(predicate: TsStream.Predicate<T>): T[][];
    partitionBy(predicate: TsStream.Predicate<T>): T[][];
    partitionBy(sample: TsStream.Sample): T[][];
    partitioningBy(regexp: RegExp): T[][];
    partitionBy(regexp: RegExp): T[][];
    partitioningBy(size: number): T[][];
    partitionBy(size: number): T[][];
    partitioningBy(sample: TsStream.Sample): T[][];
    peek(consumer: TsStream.Consumer<T>): IPipeline<T>;
    reduce(identity: T, accumulator: TsStream.Accumulator<T>): T;
    reduce(accumulator: TsStream.Accumulator<T>): Optional<T>;
    reverse(): IPipeline<T>;
    size(): number;
    sorted(): IPipeline<T>;
    sorted(comparator: TsStream.Comparator<T>): IPipeline<T>;
    sorted(path: string): IPipeline<T>;
    sort(): IPipeline<T>;
    sort(comparator: TsStream.Comparator<T>): IPipeline<T>;
    sort(path: string): IPipeline<T>;
    shuffle(): IPipeline<T>;
    skip(n: number): IPipeline<T>;
    slice(begin: number, end: number): IPipeline<T>;
    sum(path?: string): number;
    takeWhile(predicate: TsStream.Predicate<T>): IPipeline<T>;
    takeWhile(regexp: RegExp): IPipeline<string>;
    takeWhile(sample: TsStream.Sample): IPipeline<T>;
    toArray(): T[];
    toList(): T[];
    toMap(pathOrKeyMapper: TsStream.Function<T, string>|string, mergeFunction?: TsStream.Accumulator<T>): TsStream.Map<T>;
    anyMatch(predicate: TsStream.Predicate<T>): boolean;
    anyMatch(regexp: RegExp): boolean;
    anyMatch(sample: TsStream.Sample): boolean;
    allMatch(predicate: TsStream.Predicate<T>): boolean;
    allMatch(regexp: RegExp): boolean;
    allMatch(sample: TsStream.Sample): boolean;
    average(path?: string): Optional<number>;
    avg(path?: string): number;
    collect(collector: TsStream.Collector<T>): T;
    count(): number;
    distinct(): IPipeline<T>;
    dropWhile(predicate: TsStream.Predicate<T>): IPipeline<T>;
    dropWhile(regexp: RegExp): Pipeline<string>;
    dropWhile(sample: TsStream.Sample): IPipeline<T>;
    each(consumer: TsStream.Consumer<T>): void;
    filter(predicate: TsStream.Predicate<T>): IPipeline<T>;
    filter(regexp: RegExp): Pipeline<string>;
    filter(sample: TsStream.Sample): IPipeline<T>;
    findAny(): Optional<T>;
    findFirst(): Optional<T>;
    forEach(consumer: TsStream.Consumer<T>): void;
}
